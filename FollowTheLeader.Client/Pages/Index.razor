@page "/"
@inject IConfiguration Config

<PageTitle>Follow The Leader 🛣️</PageTitle>

@if (game is null) return;

@if (game.IsStarted)
{
    <div style="position:relative;">
        @if (game.Rounds.Any(r => r.Time > 0))
        {
            <div style="position:absolute;width:100%;text-align:center;font-size:30px;">@Math.Round(game.Rounds.First(r => r.Time > 0).Time, 1)</div>
            <div style="position:absolute;width:100%;display:flex;justify-content:end;font-size:30px;">
                <div style="position:relative;border-radius:10;background-color:rgba(0, 0, 0, 0.5);width:400px;">
                    @foreach (var (k, v) in game.Rounds.First(r => r.Time > 0).Points.OrderByDescending(p => p.Value))
                    {
                        var style = k == hubConnection.ConnectionId ? "font-weight:800;text-decoration:underline;" : "";
                        <div class="row" style="font-family:monospace;width:400px;">
                            <div class="col" style="@style;color:@game.Players.First(p => p.ConnectionID == k).Color;">
                                @(game.Players.First(p => p.ConnectionID == k).Name):
                            </div>
                            <div class="col">
                                @v
                            </div>
                        </div>
                    }
                </div>
            </div>
        }

        <svg @ref="@svgElement" @onkeydown=KeyDown @onkeyup=KeyUp width="100vw" height="100vh" viewBox="@minXWithPadding.AsString() @minYWithPadding.AsString() @widthWithPadding.AsString() @heightWithPadding.AsString()" tabindex="-1">
            <filter id="noise" x="0%" y="0%" width="100%" height="100%">
                <feTurbulence baseFrequency="0.1"></feTurbulence>
            </filter>

            <rect x="@bgX.AsString()" y="@bgY.AsString()" width="@bgWidth.AsString()" height="@bgHeight.AsString()" filter="url(#noise)" fill="none"></rect>
            @foreach (Player player in game.Players)
            {
                var isMe = player.ConnectionID == hubConnection.ConnectionId;
                <path stroke-width="2" stroke="@player.Color" stroke-linecap="round" d="@BodyPath(player.Body.ToArray())" fill="transparent"></path>
                <circle r="2" fill="@player.Color" cx="@player.Head.X.AsString()" cy="@player.Head.Y.AsString()" stroke="white" stroke-width="@(isMe ? "0.5" : "0")"></circle>
                @if (game.Rounds.Any(r => r.Time > 0) && player.ConnectionID == game.Rounds.First(r => r.Time > 0).Leader)
                {
                    <path stroke="black" stroke-width="0.5" fill="#FFEB3C" d="M @player.Head.X.AsString() @player.Head.Y.AsString() m -2 -1 l 0 -2 l 1 1 l 1 -1 l 1 1 l 1 -1 l 0 2 l -4 0 Z"></path>
                }
            }
        </svg>
    </div>
}
else
{
    <div style="height:100vh;display:flex;justify-content:center;align-items:center;">
        <div>
            <h1 style="text-align:center;">
                Follow The Leader 🛣️
            </h1>
            <div style="display:flex;justify-content:center;">
                <div>
                    <h2 style="text-align:center;">
                        Players
                        <hr />
                    </h2>
                    <h3>
                        <ul>
                            @foreach (Player player in game.Players)
                            {
                                if (player.ConnectionID == hubConnection.ConnectionId)
                                {
                                    <li style="color:@player.Color;font-weight:800;text-decoration:underline;">@player.Name</li>
                                }
                                else
                                {
                                    <li style="color:@player.Color;">@player.Name</li>
                                }
                            }
                        </ul>
                    </h3>
                </div>
            </div>
            <div style="display:flex;justify-content:center;">
                <button class="btn btn-success btn-lg" @onclick="StartGame">Start Game</button>
            </div>
            @if (game.ScoreBoard is not null)
            {
                <div style="display:flex;justify-content:center;">
                    <div>
                        <h2 style="text-align:center;margin-top:20px;">
                            Scoreboard
                            <hr />
                        </h2>
                        <h3>
                            @foreach (var x in game.ScoreBoard.OrderByDescending(p => p.Value).Select((Entry, Index) => new { Entry, Index }))
                            {
                                var style = x.Entry.Key == hubConnection.ConnectionId ? "font-weight:800;text-decoration:underline;" : "";
                                <div class="row" style="font-family:monospace;width:400px;">
                                    <div class="col" style="@style;color:@game.Players.First(p => p.ConnectionID == x.Entry.Key).Color;">
                                        <b style="margin-right:10px">@(x.Index + 1).</b> @(game.Players.First(p => p.ConnectionID == x.Entry.Key).Name):
                                    </div>
                                    <div class="col">
                                        @x.Entry.Value
                                    </div>
                                </div>
                            }
                        </h3>
                    </div>
                </div>
            }
        </div>
    </div>
}

@code {
    ElementReference svgElement;
    HubConnection hubConnection;
    Game? game;
    HashSet<string> keys = new();
    List<Obstacle> obstacles = new();
    double minXWithPadding;
    double minYWithPadding;
    double widthWithPadding;
    double heightWithPadding;

    //background things
    double bgX;
    double bgY;
    double bgWidth;
    double bgHeight;

    protected override async Task OnInitializedAsync()
    {
        var signalrUrl = Config.GetConnectionString("SignalRUrl");
        hubConnection = new HubConnectionBuilder().WithUrl(signalrUrl!).WithAutomaticReconnect().Build();

        hubConnection.On<Game>("Update", (game) =>
        {
            this.game = game;
            minXWithPadding = game.Players.SelectMany(p => p.Body.Select(b => b.X)).Min() - 10;
            minYWithPadding = game.Players.SelectMany(p => p.Body.Select(b => b.Y)).Min() - 10;
            widthWithPadding = game.Players.SelectMany(p => p.Body.Select(b => b.X)).Max() + 10 - minXWithPadding;
            heightWithPadding = game.Players.SelectMany(p => p.Body.Select(b => b.Y)).Max() + 10 - minYWithPadding;
            if (widthWithPadding / heightWithPadding < 21.0 / 9.0)
            {
                // Height is too small
                var offset = heightWithPadding * 21.0 / 9.0 / 2;
                bgX = minXWithPadding - offset;
                bgWidth = widthWithPadding + offset * 2;
                bgY = minYWithPadding;
                bgHeight = heightWithPadding;
            }
            else
            {
                // Width is too small
                bgX = minXWithPadding;
                bgWidth = widthWithPadding;
                bgY = minYWithPadding;
                bgHeight = heightWithPadding;
            }
            StateHasChanged();
        });

        await hubConnection.StartAsync();

        await hubConnection.InvokeAsync("Join");

        await Task.Run(async () =>
        {
            while (true)
            {
                var direction = 0;
                if (keys.Contains("ArrowLeft") && keys.Contains("ArrowRight"))
                {
                    direction = 0;
                }
                else if (keys.Contains("ArrowRight"))
                {
                    direction = -1;
                }
                else if (keys.Contains("ArrowLeft"))
                {
                    direction = 1;
                }
                await hubConnection.SendAsync("Direction", direction);

                var speed = 0;
                if (keys.Contains("ArrowDown"))
                {
                    speed = -1;
                }
                else if (keys.Contains("ArrowUp"))
                {
                    speed = 1;
                }
                return 0;
                await hubConnection.SendAsync("Speed", direction);
                await Task.Delay(20);
            }
        })
    }

    private async Task StartGame()
    {
        await hubConnection.SendAsync("StartGame");
        StateHasChanged();
        await Task.Delay(500);
        await svgElement.FocusAsync();
    }

    private void KeyDown(KeyboardEventArgs eventArgs)
    {
        keys.Add(eventArgs.Code);
    }

    private void KeyUp(KeyboardEventArgs eventArgs)
    {
        keys.Remove(eventArgs.Code);
    }

    private string BodyPath(Position[] points)
    {
        // Parameter for smoothness of path in interval [0, 0.5]
        double smoothness = 1.0 / 3.0;

        var result = "";
        if (points.Length >= 2)
        {
            result = $"M {points[0].X.AsString()} {points[0].Y.AsString()} ";
            for (int i = 1; i < points.Length - 1; i++)
            {
                result += $"S {(points[i - 1].X * smoothness / 2 + points[i].X - points[i + 1].X * smoothness / 2).AsString()} {(points[i - 1].Y * smoothness / 2 + points[i].Y - points[i + 1].Y * smoothness / 2).AsString()} {points[i].X.AsString()} {points[i].Y.AsString()} ";
            }
            result += $"S {(points[^2].X * smoothness + points[^1].X * (1 - smoothness)).AsString()} {(points[^2].Y * smoothness + points[^1].Y * (1 - smoothness)).AsString()} {points[^1].X.AsString()} {points[^1].Y.AsString()} ";
        }
        return result;
    }
}
